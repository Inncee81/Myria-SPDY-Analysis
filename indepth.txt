This is a more indepth attempt at explaining the necessary steps used to ultimately generate the dependency graph.

Calling Structure:

Analyze.pl -> ProcessMain.pm -> RawParser.pm -> Dependency.pm

ProcessMain:run() -> ProcessMain:generateIntermediaries() -> RawParser:parse()/genIntermediaries() -> Dependency:process() -> bunch of add calls -> Dependency:generateDependencyGraph()/criticalPathAnalysis() -> UtilPlot.pm funtions

generateDependencyGraph():
	Takes self, info, parses
	It gets the resources it requires
		Resources: The original resources table
		Comps_post_l: Computations after 1
		comps_post_n: Computations after n
		url: ID
		objecthashes: 
		PageStart: time
	
	Initializes the graph
		name: url
		objs: the ???
		deps: the dependencies for objects
		start_activity: start time of activity
		load_activity: set to -1
	Opens a file
		dep_logs/url
	
	Constructs the downloads: Created from the resources table
		Adds the downloads onto an array from resources
		starting from the first download

	Adds parameters to graphs (for loop)
		Creates an object "array"
			ID: The code id?
			URL: The URL
			when_comp_start
			download type: the type of download
			download s_time: The start time for each download
			download id: the object ID
			comps: set to empty
		Pushes object array onto the graph's object array
		Sets graph->startActivity to the download ID if the graph->startActivity is not initialized/DNE
	Constructs the parses and computations (for loop)
		Take an element from parses
			Find the corresponding download activity
				Take an element from the graphs->objs
					if the url matches the parses'
						set the object to the element
			Creates a comp object/array and initializes its elements
				id: obj->id
				type: always evalhtml
				s_time: start time is parses start
				e_time:
			if p->during_l
				cut HTML evaluation into activities by parsing blocking JS (if 4 (css) skip because CSS doesn't block)
					Finish current activity
					Start a new activity (comps again)
						id: obj->id
						type: evalHTML all the time
						s_time: during_l->endTime
					Add a dependency because the new activity depends on completion of during_l
						id: Dependency ID usually incremental
						a1: Depends on a certain computation
						a2: Id of the dependent activity.
						time: -1 because it requires it to completely finish before starting
				e_time: End time 
				comps: set comps to empty array if it doesnt exist
				objs[i]: sets the graph object array
				for during_ll if p->during_l
					find corresponding object
					set comp fields
						id: Object ID
						type: HOL_Type
						s_time: The Start time
						e_time: The End time
					print out info
					add output dependency: (for pr in prev)
						Create dep list
							id: dep id
							a1: ID
							a2: Obj_id
							time: -1
	Construct comps outside of parses:
		For my cc in comps_post_l
			Find corresponding object
			If obj is not found, this should evaluate a data url which has been included in another comp, so skip
	Add E2D dependency info
 		This might change e_time of a comp activity
  		Note that we do this backward to make sure that e_time is changed first
  			Get obj
  				get parse
  				get comp if no parse
  					get comp in obj
  					add dep
  						id: dep id
  						a1: comp->id
  						a2: obj->download->id
  						time: obj->download->s_time - comp->s_time
  						if obj->download->s_time > comp->e_time
  							comp->e_time = obj->download->s_time
  							dep->time = -1
  						If no comp is matched, it means that this object download is triggered
  					Get obj_parse
  					Add dependency
  		Calculate elapsed time in comp

  		2262397.518433
